Суть:
1) Работать с View-элементами можно только на главном потоке
2) Чтобы из фоновых потоков взаимодействовать с главным потоком используется класс Handler
3) Handler использует очередь сообщений из класса Looper
4) При создании объекта Handler ему нужно передать Looper в качестве параметра, с указанием на
каком потоке нужно обрабатывать события:
Looper.getMainLooper() - если события нужно обрабатывать на главном потоке
Looper.myLooper() - если события нужно обрабатывать на потоке вызова (в этом случае перед созданием
лупера нужно обязательно указывать Looper.prepare())
5) Handler-у можно передавать объекты типа Runnable или Message
6) При передаче объектов типа Runnable нужно вызвать методы post(Runnable) или postDelayed(Runnable)
если сообщение должно быть отложено на какое то время.
7) при передаче объектов типа Massage используются методы sendMessage(Massage) или sendMessageDelayed(Massage)
8) Чтобы обрабатывать сообщения типа Massage нужно создать его наследника и переопределить метод handleMessage()
9) У объектов типа Runnable метод run() будет вызван автоматически
____________________________________________________________________________________________________
Thread — поток выполнения инструкций. Также, можно рассматривать как отдельную задачу, в которой
выполняется независимый набор инструкций.

Message — сообщение представляет собой контейнер для набора инструкций, которые будут выполнены в
другом Thread-e.

MessageQueue — класс низкого уровня, содержащий список сообщений. Позволяет перекидывать данные из
одного потока в другой. В такую очередь можно добавлять задания из других потоков, заданиями могут
быть переменные, объекты или кусок кода для исполнения (Runnable).
Чтобы организовать MessageQueue, нужно воспользоваться классами Handler и Looper: первый отвечает за
организацию очереди, а второй в бесконечном цикле проверяет, нет ли в ней новых задач для потока.

Handler — класс который позволяет взаимодействовать с Looper-ом. С помощью Handler-а можно отправить
Message, через реализацию интерфейса Runnable, в Looper. Message будет Thread-ом с которым связан сразу
или через некоторое время. Привязка между Handler-ом и целевым Thread-ом(например MainThread)
достигается с помощью Looper и MessageQueue. A Handler всегда привязан к a Looper-у, а затем привязан
к Thread-у, связанному с Looper-ом. В отличие от Looper-а, несколько экземпляров Handler-а могут быть
привязаны к одному и тому же Thread-у. Всякий раз, когда мы вызываем post()  или любые подобные методы,
новый Message добавляется к связанному MessageQueue. Когда вы создаете новый Handler, он привязан к
Thread-у, который его создает. Он будет доставлять Message-ы и Runnables в MessageQueue и выполнять
их при выходе из MessageQueue.
____ Handler
Для того чтобы отправить данные в основной поток у нас есть класс Handler
Handler представляет собой очередь сообщений, к которой мы задем поток в котором она будет работать
и дальше сообщаем ей, что мы хотим исполнить такой то код и он исполнится в нужный момент.
Для указания потока в котором мы хотим, чтобы он работал, указываем .getMainLooper() – главный поток.
Отдельная функция, runOnUiThread{ } которая делает тоже самое. По сути это упрощение.
____


Looper — реализует бесконечный цикл обработки сообщений. Looper преобразует нормальный Thread, который
заканчивается, когда возвращается его метод run(), в то, что работает непрерывно до тех пор, пока
приложение Android не будет завершено.  Looper предоставляет MessageQueue, который необходим в
графическом интерфейсе. Каждый Looper уникален для каждого Thread-a. Чтобы гарантировать эту ассоциацию,
Looper хранится в потоковом локальном хранилище и не может быть создан через его конструктор напрямую.

Main Thread является по сути Looper Thread-ом.