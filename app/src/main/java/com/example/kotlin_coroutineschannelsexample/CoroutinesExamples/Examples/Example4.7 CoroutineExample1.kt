package com.example.kotlin_coroutineschannelsexample.CoroutinesExamples.Examples

import kotlinx.coroutines.*

fun main() = runBlocking {

    // Рассмотрим корутины на примере,

    // Теперь выведем наши жучки и приведения при помощи корутин.

    // Сначала мы выведем мячики в первой корутине через цикл. Затем мы усыпляем эту корутину на
    // 300 миллесекунд при помощи delay() и затем мы выведем еще 500 жучков – это первая корутина.
    // Далее мы запускаем вторую корутину, которая будет выводить призраков, но она уже не будет
    // засыпать. Теперь у нас две корутины и в конце выведем строку в лог, что все завершилось.

    launch {
        for (i in 0..500) {
            println("$i \uD83d\uDC1C")
        }
        delay(300)
        for (i in 0..1000) {
            println("$i \uD83d\uDC1C")
        }
    }
    launch {
        for (i in 0..999) {
            println("$i \uD83d\uDc7b")
        }
    }
    println("End")

    // Запускаем. И здесь происходит следующее, внутри блокирующей корутины созданы две другие
    // (стандартные), которые вызваны последовательно, одна за другой. Они не знают друг о друге.

    // Обращаем вримание, в логе у нас сначала выводится End
    // У нас вывелось 500 жучков и в этот момент корутина засыпает на 300 mls

    // Если бы мы сделали обычными средствами, например потоками, то поток будет проставиться,
    // а здесь после пятисотого жучка, корутина отдала процесс другой корутине, которая начала выводить
    // призраков.

    // Таким образом все это время поток работает и выполняет какие то полезные действия.
    // Вместо того, чтобы занять собой весь поток и никому его не отдавать, корутины предпочитают “делиться”.
    // т.е. в момент delay() она отдает выполнение другой корутине, да делает полезную работу,
    // затем первая просыпается и продолжает выводить жучков.

    // В этом специфика корутин. Если мы будем делать это при помощи потоков со слипом, то у нас
    // все заблокируется и такой параллельной работы не будет.
}



