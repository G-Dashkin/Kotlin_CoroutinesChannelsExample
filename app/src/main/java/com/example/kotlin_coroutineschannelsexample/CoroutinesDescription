Корутины - это функции, которые могут приостанавливать свое выполнение, тем самым не блокируя поток выполнения
После приостановки корутина может восстановиться на любом доругом потоке.

т.е. когда мы используем потоки нам каждый раз  приходится тратить ресурсы на создание новго потока.
например создать 1000 потоков для какой-то трудозатратной операции потребует множество ресурсов.
А при использовании 1000 корутин будет использоваться заранее заданный пул потока в который будет
переноситься выплнение задачи.

Поэтому suspend ("приостанавливаемый") имеется в виду, что не функция приостнавливается и больше ничего
неделает, а она приостанавливается на том потоке на котором мы ее вызываем и переводит свое выполнение
в другой поток. В то время как на основном потоке ресурсы освобождены и он не заблокирован т.к. функция
на нем приостановлена.

"Легковесность" этих потоков в том, что они не создаются с 0, а используется заранее заданный пулл
потоков и в этот пул переносятся процессы выполнения функции

"Суть корутин" - они могут остановить свое выполнение в определенной точке, зафиксировать свое состояние,
а затем, через некоторое время восстановить работу. При этом пока она “спит” поток выполнения
освобождается – это называется кооперативная многозадачность. т.е. она не занимает собой (своим спящем
телом) наш процессор, она аккуратно освободит его другим, а затем проснется и вернет его себе.

-Если разбираться, как работают корутины "под капотом", то по сути использование корутин, это
программировании с коллбэками. Сами коббэки мы не видим, но они будут создана компилятором.
Просто разработчики kotlin сделали удобные оболочки благодоря которым код каждется последовательным

-Основные преимущества корутин это синхронный стиль кода и возможность создания легковесных потоков.
т.е. это не всегда является обычными тредами и преимущество таких потоков в том, что они теряют гораздо
меньше ресурсов на их выполнение. т.е. если мы создадим 100 тредов, то наш код сильно замедлится, но
те же 100 будут работать быстрее.

-В основе корутин лежат suspend-функции (прерываемые функции). Это функции выполнение которых может
быть приостановлено.  Например код этой функции выполняется, далее ждет ответ от сервера и код в
основном или другом потоке начинает выполняться.

-Под капотом suspend-функции являются (используют) state-машину, чтобы один и тот же метод можно было
вызвать с разными состояниями
____________________________________________________________________________________________________
Suspend-функции - функции которые могут прерываться
По сути внутри Suspend-функций реализованы те же самые коллбэки, которые мы бы писали сами.
В итоге получается, внутри Suspend-функций тот же саммы Callback-Hall, но за счет обертки корутин
мы можем писать асинхронный код в синхронном стиле.

Suspend-функции в котлин реализованы следующем образом:
-Каждая из таких функций разворачивается в конченый автомат – state-машину, состояние которого
соотвествует точкам пристановки Suspend-функции.
-С точки зрения реализации конченый автомат это анонимный класс в полях которого сохраняются значения
переменных из области видимости функции.
-Этот анонимный класс имеет метод resumeWith() для перехода от одного состояния к другому.
-Suspend–функции возвращают свой ответ асинхронно, поэтому их нельза запускаать в обычном синхронном
коде (так как это асинхронная операция), из обычной функции
____________________________________________________________________________________________________
Для большего понтмания корутин нужно рассмотреть следующие понятия:

"Процесс" – это совокупность кода и данных, которая имеет общее виртуальное адресное пространство.
По умолчанию все компоненты одного приложения работают в одном процессе и вы, в 99% случаях не должны
менять это поведение. Помимо процесса, операционная система создает главный поток процесса.

"Поток" (Thread) – это единица исполнения кода. Каждый поток последовательно выполняет инструкции
процесса, которому он принадлежит. Кроме основного потока, в процессе могут быть дополнительные потоки,
которые работают параллельно с главным.

"Многопоточность" - способность выполнять несколько задач одновременно в разных потоках
Базовый способ создания многопоточности это – объект Thread
Объект Thread – это стандартный Java объект, который не отнсится к Android SDK. То что мы хотим выполнять
в паралельном потоке мы указываем в функции run() и после этого у нашего экземпляра объекта нужно вызвать
функцию .start(). В котлине более короткий синтаксис.
"Многопоточность на основе процессов" - дает возможность разным программам или процессам работать
одновременно/параллельно.
"Многопоточность на основе потоков" - дает возможность выполнять одновременно/параллельно несколько
задач в рамках одной программы.

"Асинхронность" - выподнение несколько действий одновременно в рамках одного потока, а не создание
отдельных потоков для каждого действия. Основной поток не блокируется на длительное время, все долгие
операции выполняются в фоне, а основной поток просто дожидается результатов этих долгих операций.
Во время ожидания он может заниматься другими полезными операциями.

"Блокировка потока" - выполнение долговременных операций в основном потоке (в случаем с Android), таких
как сетевой доступ или работа с файлами или базой данных. Когда поток заблокирован, не могут обрабатываться
никакие события, включая события изменения отображения. С точки зрения пользователя приложение выглядит
зависшим. Если поток пользовательского интерфейса заблокирован более нескольких  секунд (в настоящее
время около 5 секунд), отображается печально известное диалоговое окно «приложение не отвечает».
____________________________________________________________________________________________________
Coroutine Scope “область корутины” - Любая корутина может быть запущена только в так называемой
“область корутины”. Область корутины – это специальная структуктра, которая отвечает за жизненный
цикл корутин и за связь между ними. Область корутины содержит “контекст корутины” – Coroutine Context
(она хранит информацию о названии корутины, диспатчер и т.д.)

сoroutineScope{} - специальная функция, которая позволяет создать область корутин, без запуска корутины

CoroutineScope - это основной компонент для управления корутинами. Он предоставляет API для запуска
и отмены корутин и позволяет определять, на каком потоке должны выполняться операции. CoroutineScope
также позволяет управлять жизненным циклом корутин и предотвращает утечки памяти. Рассмотрим более
подробно, как работает CoroutineScope и как он используется в мобильной разработке. Это интерфейс,
который предоставляет функции для запуска и управления корутинами. Корутины запускаются внутри
CoroutineScope, который определяет их жизненный цикл и контекст выполнения.

GlobalScope - это глобальный CoroutineScope, который может быть использован для запуска корутин в
приложении. Он не связан с жизненным циклом компонентов Android и продолжает выполнение корутин,
даже если активность или фрагмент были уничтожены.

LifecycleScope - является удобным способом создания CoroutineScope, связанного с жизненным циклом компонента
LifecycleOwner (например фрагмента или активности). Преимуществом использования lifecycleScope является
автоматическая отмена корутин. Корутины, запущенные в lifecycleScope, автоматически отменяются при уничтожении
фрагмента или активности. Вам не нужно беспокоиться о явной отмене корутин: это происходит автоматически.

ViewModelScope - это CoroutineScope, связанный с жизненным циклом ViewModel. Он автоматически отменяет
все связанные с ним корутины при уничтожении ViewModel.

runBlocking{} - является “мостиком” в асинхронном коде между блокирующим и не блокирующим кодом. Она
создает область корутин и дожидается выполнения всех связанных с ней операций. При этом поток функции
main() блокируется на время вызова runBlocking{}, а внутри она работает ассинхронно. runBlocking{} позволяет
запускать любые suspend-функции внутри блокирующих функций.
____________________________________________________________________________________________________
Structered Concurrency (Структурированная Асинхронность) - При вызове билдеров launch{} и async {}
ресиверных лямбд так же является Coroutine Scope. Это означает, что внутри них можно запускать вложенные
launch{} и async {} и они станут дочерними по отношению к внешней корутине. Этот межанизм называется –
Структурированая конкурентность и он дает следующие преимущества:
- внешний Coroutine Scope отвечает за все запущенные в нем корутины и их жизненный цикл привязан к
жизненному циклу скоупа.
- Scope от меняет все запущенные в нем коруины, если его выполнение было прервано или отменено
- Scope дожидается завершения или отмены всех запущенных в нем корутин.

Continuation - Continuation можно рассматривать как колбэк. Continuation — похож на огромную стейт-машину,
где на каждый кусок Корутин-кода(Suspend-функции) есть свой Switch-Case. Continuation нужен для того
чтобы код расположенный после suspendedGetFile() — а это println() — был исполнен только после завершения
supendedGetFile(). Для этого код делится switch-ем на две части и добавляется переменная label.
Точка разделения кода на две части — это suspend-функция.

Основная задача Continuation — сделать так, чтобы код, расположенный после вызова функции download(),
был выполнен только когда метод download() завершил работу. Для этого код делится switch-ем на две части.
И добавляется переменная label. Точка разделения кода на две части — это suspend-функция. От значения
переменной label зависит, какая из двух частей будет выполнена при вызове invokeSuspend(). В нашем
примере invokeSuspend() будет вызван 2 раза. Ключевые слова «case» в данном случае стоит понимать как «шаги».

Таким образом Continuation является колбэком для suspend-функции. Если в корутине есть несколько
suspend-функций, то Continuation будет колбэком для всех них.

Возврат значения suspend-функцией
Suspend-функция может возвращать какое-либо значение, как результат своей работы. Давайте посмотрим, как эта ситуация обрабатывается в Continuation.

Стейт-машина - функция переборки описанных состояний, обычно через switch-case. При компиляции, suspend-функции
преобразуются в стейт-машину, в которой описывается каждый блок из функции и на каждом этапе состояния
производятся необходимые действия.
----------------------------------------------------------------------------------------------------
Корутин-билдеры и их основные методы:

Job - класс позволяющий управлять корутиной (отменять ее работу или дождаться завершения)
Когда мы создаем корутину, на самом деле мы создаем объект Job – этот объект управляет жизненным циклом
корутины (т.е. ее стартом, окончанием и отменой). У корутины есть несоклько сотояний – 1.С корутиной
ничего не происходит, 2.Корутина стартована, 3.Корутина отменена, 4.Корутина закончина. Эти состояния
можно проверять. Так же есть функция .join() – она означает “ждать пока корутина не закончится”.

Deferred - Это наследник Job, поэтому имеет все те же методы. Но дополнительно у него есть методы
для получения результата работы корутины. Один из них — метод await.

launch{} - основной билдер корутины, возвращает объект Job для управления корутиной
async{} - расширенный билдер корутины, возвращает объект Deferred для управления корутиной и получения
объекта/данных из корутины

Отличие async{} в том, что при запуске (если не указано иное), начинает исполняться сразу, так же как
launch{} т.е. в том месте где код async{} там и начинает исполняться этот код, но результат этого
исполнения возвращается, когда нам нужно, при помощи функции .await() вызванной у объекта Deferred.

.join() - данный метод приостаноивит выполнение дальнейших функций в потоке до тех пор, пока работа
корутины не будет завершени. т.е. этот метод заставит ждать завершения выполнения корутины
.await() - данный метод возвращает значение из корутины полученное через suspend-функцию у билдера async{}

.joinAll() - Ожидание завершения работы всех корутин от всех экземпляров корутин
.awaitAll() - получения результатов от всех экземпляров корутин

.start() - запускает корутину если у нее указан отложенный запуск в билдере .launch(start = CoroutineStart.LAZY)
.isActive() - проверяет активна ли/работает ли еще корутина
.cancel() - отмена работы корутин
.isCancel() - проверка отмененали работа корутина, не завершившись до конца
.complete() - принудительное завершение кортины
.isCompleted() - проверка завершилали и корутина свою работу

Эти функции связаны с жизненным циклом корутины:
"Запуск" [New] -> [Active] -> "Завершение" [Completing] -> "Конец" [Completed]
                        -> "Отмена/Ошибка" [Cancelling] -> "Конец" [Cancelled]
____________________________________________________________________________________________________
CoroutineContext - здесь мы можем задать параметеры этой корутины:
1. Dispatchers в котором она исполняется
2. Параметры для Job т.е. для самих корутин.
3. Можно задать обраотку исключений
4. Название корутины (нужен для отладки).

delay() - неблокируюцая функция остановки корутины
withContext() - переключатель диспатчера потока
____________________________________________________________________________________________________
Диспатчеры - Каждый КорутинБилдер принимает в качестве необязательного параметра Context, который
можно использовать для явного указания контекста(и соответственно диспетчера). Если диспетчер не
указан, то будет использоваться диспетчер родительского скоупа. Диспетчер определяет в како потоке
будет выполняться корутина.

Dispatchers.Main - означает, что корутина будет выполнятсья на основном потоке (на одном) и здесь мы
можем взаимодействовать c UI.Прямо в процессе выполнения корутины мы можем переключиться на другой
поток, не создавая новую корутину, с помощью функции - withContext()

Dispatchers.IO - оптимизированный под выполнение операций Input-Output т.е. для операций на сервере.

Dispatchers.Default - использует пул потоков по количеству ядер процессора, но не меньше двух.
Обеспечивет максимальную скорость вычислений, запущенных параллельно.
Подходит для стандартных сложновычислимых операций.
Отличае Dispatchers.IO от Dispatchers.Default в том, что Default по умолчанию использует либо два
потока, либо столько потоков сколько у нас ядер процессора. т.е. он максимально оптимизирует код так,
чтобы он исполнялся на разных ядрах, но не исполнялся на одном ядре. И чтобы не создавалось лишних
потоков, если ядер у нас не хватает. Dispatchers.IO по умолчанию создает 64 потока и это очень удобно
для операций, которые никак не нагружают процессор, но долго ждут ответа. т.е. мы можем запустить 64
корутины на Dispatchers.IO они все будут в разных тредах и все будут ждать какого то ответа.

Dispatchers.Unconfined - запускает корутину немедленно на том же потоке, на котором запускалась другая
корутина. Продолжаем работу в том потоке, в котором была вызвана корутина. Это нужно в том случае если
мы вызываем ленивую корутину и мы знаем, что эта корутина будет стартовать в разных потоках, а нам важно,
чтобы операция исполнялась в том же самом потоке, в котором мы ее стартанули, чтобы небыло каких то переключений.
____________________________________________________________________________________________________
Корутины позволяют создавать асинхронные потоки используя Channels и Flows

Channels - позволяют передавать объекты/данные между корутинами.
Основыные методы Send - положить объект в канал, Receive - получить объект из канала

Flows - позволяют создавать аснихронные потоки данных. Класс Flows может возвращать несколько объектов
по очереди или сразу (корутины позволяют возвращать одиночные значения), а также использовать операторы
преобразования данных типа .map{} и .filter{}
Flows использует паттерн наблюдатель, т.е. мы можем подписываться на обновление объекта данных и получать
их без блокирования основного потока приложения.
Основыные методы Emit - имитирование получения объектов в поток, Collect - получение объектов из потока