package com.example.kotlin_coroutineschannelsexample.CoroutinesExamples.Examples

import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking


// Для того, чтобы запускать такие функции в функции main() нужен специальный корутинБилдер, который
// называется runBlocking{} и функция launch{} теперь работает.

// runBlocking{} это самый простой способ создать корутину. Эта такая функция, которая создаст
// корутину и вернет ее нам. Это специфичная функция, так как ее создали, для того, чтобы запускать
// корутины в main() и тестировать.
//т.е. это своеобразный мост между асинхронным миром корутин и синхронным миром функций main().

// Для того, чтобы запускать корутины в main() мы используем функцию runBlocking{}
// Функция runBlocking{} вернет корутину с уникальной способностью – она завершит свое выполнение
// только тогда, когда завершат выполнение все асинхронные вызовы внутри неё.

fun main() = runBlocking<Unit> {// Здесь появляются подсказки – CoroutineScope (область корутины)
    launch {  // Здесь тоже

    }

    // CoroutineScope по сути это некоторая область жизни корутины, которая ограничивает ее жизнь и
    // в какой то момент может прекратить ее жизнь. CoroutineScope содержит внутри себя ссылку на
    // контекст корутины.

    // Если мы запустим две корутины, то у каждой из них будет свой собственный скоуп и мы можем
    // управлять их жизнью. Ниже, розовым выделен внешний скоуп, а внутренняя корутина будет иметь свой
    // собственный скоуп, который еще подчиняется внешнему.

    // Например в андроиде, корутины которые будут запущены в рамках LifecycleScope будут уничтожены,
    // как только хранитель жизненного цикла сам будет уничтожен.
    //т.е. мы запустим кучу корутин в LifecycleScope в какой то активити, то как только эта активити
    // будет уничтожена, все корутины, которые связаны с этим LifecycleScope так же удалятся.
    //Таким образом LifecycleScope позволяет учитывать жизненный цикл наших компонентов при работе с
    // корутинами. В обычных потоках такого нет.
}



