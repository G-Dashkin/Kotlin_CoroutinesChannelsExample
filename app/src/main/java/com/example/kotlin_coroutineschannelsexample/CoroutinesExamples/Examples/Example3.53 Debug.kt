package com.example.kotlin_coroutineschannelsexample.CoroutinesExamples.Examples

import kotlinx.coroutines.*

fun main() = runBlocking {
    // Корутина может начать свое выполнение в одном потоке, затем приостановить его и продолжить
    // выполнение в другом потоке.
    // Часто без специальных инструментов, сложно понять, что делает корутина.

    // Мы можем при помощи - дебагера понять в каком потоке выполняется корутина и в каком состоянии
    // она сейчас находится.

    // Рассмотрим использование дебагера на примере, напишем этот код.

    val a = async {
        println("[${Thread.currentThread().name}] Computing first result")
        val a1 = 2
        val a2 = 3
        // Установим брейкПоинты
        a1 + a2
    }

    val b = async {
        println("[${Thread.currentThread().name}] Computing second result")
        val b1 = 4
        val b2 = 5
        b1 + b2
    }
    println("[${Thread.currentThread().name}] The answer is ${a.await() + b.await()}")

    // Запустим выполнеине в режиме дебага. В отладчике мы должны видеть состояние всех имеющихся корутин.
    // Первая корутина запущена (развернуть блок корутин), вторые две созданы, но еще не запущены.
    // Можно переключить на DumpKt(блок снизу слева) и здесь видно, какие корутины запущены.

    // Продолжим выполнение
    // И видим, что первая корутина приостановилась и запустилась вторая корутина.

    //______________________________________________________________________________________________
    // еще одна полезная опция JVM - Dkotlinx.coroutines.debug. Она позволяет выводить имя корутины,
    // вместе с именем потока и поддерживается всеми логирующими фреймВорками.
    // Добавим опцию -Dkotlinx.coroutines.debug (смотреть на скринах в описании, штука удобная)
    // Запускаем код и теперь мы видим как название потока выводится с ней.  К названию потока
    // добаляется название корутины.

}