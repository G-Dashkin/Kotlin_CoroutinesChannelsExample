package com.example.kotlin_coroutineschannelsexample.CoroutinesExamples.Examples

import kotlinx.coroutines.*

fun main() = runBlocking {

    // Перейдем к рассмотрению корутинБилдера - launch {} он создает простую корутину, которая не
    // блокирует текущий поток и возвращает ссылку на эту корутину, а видео объекта Job

    // launch {} - корутин билдер вызывающий новую корутину, без блокировки текущего потока,
    // возвращает Job-ссылку на корутину
    val job = launch {
        println("Coroutine 2 " + Thread.currentThread().name)
        repeat(1000) {
            println("$it \uD83d\uDc7b")
            // Усыпим корутину через 300 миллесекунд после вывода призрака
            delay(300)
        }
    }
    // отменим корутину через 3 секунды. Мы здесь можем так же вызвать delay{} так как весь код
    // внутри другой блокирующей корутины. Остальные корутины закомментируем.
    delay(3000)
    // При помощи этого объекта Job мы можем например, отменить эту корутину используя метод .cancel()
    job.cancel()
    println("End")

    // Запускаем код. У нас пошли призраки и через 3 секунды и джоба отменилась. Затем был вызван
    // Таким образом, мы можем корутину останавливать вручную в нужный момент.

    // launch{} это самый простой способ создания корутины и работы с ними. Мы можем передавать
    // конкретный диспатчер как параметр, т.е. в скобочках указывать, что мы будем запускать корутину
    // не на главном потоке, а на каком то другом.

}



