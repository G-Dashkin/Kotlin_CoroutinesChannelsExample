package com.example.kotlin_coroutineschannelsexample.CoroutinesExamples.Examples

import kotlinx.coroutines.*

fun main() = runBlocking {

    println("Main " + Thread.currentThread().name)

    val deferred = async {
        var sum = 0
        for (i in 0..1000) {
            sum+= i
            // Снизим до 10
            delay(10)
        }
        sum
    }
    println(deferred)
    println(deferred.await())

    // Запускаем приложение и сначала выводится ссылка на эту Deferred корутину. т.е. это корутина,
    // которая в будущем получит значение и его можно будет раздать и потом выводится сумма т.е.
    // значение объекта sum

    // Это происходит следующем образом, у нас запускается корутина и сразу же срабатывает вывод ссылки на нее.
    // Затем компилятор наталкивается на .await() и знает, что в этот момент нужно опять уснуть, до
    // тех пор пока не появится ответ.

    // async{} нам пригодится если мы отправили запрос на сервер и хотим, например, чтобы вместо этой
    // суммы нам вернулся массив данных.

    // Так же мы можем создать несколько асинков с разными запросами, затем объединить результат и
    // посмотреть, что получится.

    // Повторим основные понятия:

    // Suspend - функция может приостановить свое выполнение, не блокируя поток

    // runBlocking{} - для main() и тестирования
    // launch {} - "запустили и забыли"
    // async {} - когда нужен результат вычислений

    // CoroutineDispatcher - в каком потоке запускать
    // Job - ссылка на корутину для управления ею
    // Deferred<T> - тут появлится результат вычислений из async{}
    // Дождаться резултата - await()

    // Scope - область жизни корутин
    // Context - набор настроек пведения корутины

}



