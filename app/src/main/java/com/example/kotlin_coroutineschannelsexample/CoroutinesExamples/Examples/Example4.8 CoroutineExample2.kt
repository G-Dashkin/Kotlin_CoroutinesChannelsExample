package com.example.kotlin_coroutineschannelsexample.CoroutinesExamples.Examples

import kotlinx.coroutines.*

fun main() = runBlocking {

    launch {
        // Теперь выведем название текущего потока, в котором крутится корутина.
        println("Coroutine 1 " + Thread.currentThread().name)
        for (i in 0..500) {
            println("$i \uD83d\uDC1C")
        }
        delay(10) // Поставим очень маленькое время для усыпления корутины.
        for (i in 0..1000) {
            println("$i \uD83d\uDC1C")
        }
    }
    launch {
        println("Coroutine 2 " + Thread.currentThread().name)
        for (i in 0..999) {
            println("$i \uD83d\uDc7b")
        }
    }
    println("End")

    // Запускаем,
    // Первая и вторая корутина работают в главном потоке т.е. потоки не созданы и все происходит
    // в одном потоке.
    // Таким образом происходит симуляция работы на одном и том же потоке. Суть в том, что корутины
    // умеют останавливать свое выполнение и отдавать ресурсы для выполнения других задач.

    // При этом первая корутина не проснется до тех пор пока первая не отработает.
    // Мы поставили время для усыпления корутины всего 10 млс и все равно сначала выведется 500
    // жучков, затем закончатся выводиться призраки и только после их окончания продолжится жучки.

}



