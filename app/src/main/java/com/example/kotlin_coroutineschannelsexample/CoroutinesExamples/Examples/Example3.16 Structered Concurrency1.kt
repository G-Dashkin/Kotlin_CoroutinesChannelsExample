package com.example.kotlin_coroutineschannelsexample.CoroutinesExamples.Examples

import kotlinx.coroutines.*
import kotlin.system.measureTimeMillis

fun main() {
    // При вызове билдеров launch{} и async {} ресиверных лямбд так же является Coroutine Scope. Это
    // означает, что внутри них можно запускать вложенные launch{} и async {} и они станут дочерними
    // по отношению к внешней корутине. Этот межанизм называется – Структурированая конкурентность
    // (Structered Concurrency) и он дает следующие преимущества:
    //- внешний Coroutine Scope отвечает за все запущенные в нем корутины и их жизненный цикл привязан
    // к жизненному циклу скоупа.
    //- Scope от меняет все запущенные в нем коруины, если его выполнение было прервано или отменено
    //- Scope дожидается завершения или отмены всех запущенных в нем корутин.

    // Рассмотрим на примере, который демонстрирует дочерние связи между коруинами.
    // У нас есть родительский Скоуп запущенный в runBlocking{} и замерим время выполнения

    println("[${Thread.currentThread().name}] Start")
    val time = measureTimeMillis {
        runBlocking {
            // Добавим дочерние коруины. Итак, у нас есть внешний скоуп от runBlocking{}, внутри него
            // два вложенных скоупа запущенных через launch{} и в первом из них мы запускаем 3 лаунча
            // – два из них на этом же лаунче и один на GlobalScope
            println("[${Thread.currentThread().name}] Outer scope")
            launch {
                println("[${Thread.currentThread().name}] Inner scope 1")
                launch {
                    println("[${Thread.currentThread().name}] Inner launch 1")
                    delay(2000)
                }
                launch {
                    println("[${Thread.currentThread().name}] Inner launch 2")
                    delay(3000)
                }
                GlobalScope.launch {
                    println("[${Thread.currentThread().name}] Global Scope launch")
                    delay(4000)
                }
            }
            launch {
                println("[${Thread.currentThread().name}] Inner Scope 2")
                delay(1000)
            }
        }
    }
    println("[${Thread.currentThread().name}] Execute time: $time")
    println("[${Thread.currentThread().name}] Finish")

    // Запускаем программу и смотрим на порядок запуска корутин

    // У каждого приложения есть глобальная область корутин – Global Scope, внутри которой мы
    // запускаем runBlocking{} и он создает свою область корутин, которую мы назвали - Outer scope.

    // Далее происходит вызов первого лаунча и он создает свою область корутины.

    // Затем вызывается второй лаунч, который в свою очердь так же создает область корутины.

    // Далее в первой области корутины вызвается первый вложенный лаунч

    // Затем второй вложенный лаунч,

    // Далее третий лаунч, но его вызов происходит в глобальной области корутин

    // Общее время выполнения функции main() составит около трех секунд – по длительности выпонения
    // самой вложенной корутины. При этом корутина длительностью 4 секунды запускается в глобальной
    // области корутин – это специальная область в которой можно запускать независимые корутины и ее
    // жизненный цикл связан с жизенным циклом приложения, поэтому скоре всего наша корутина в этой
    // глобальной области даже не успеет завершится, потому, что приложение завершит свою работу раньше.

}