package com.example.kotlin_coroutineschannelsexample.CoroutinesExamples.Examples

import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking

fun main() = runBlocking {
    //Суть корутины – она может остановить свое выполнение в определенной точке, зафиксировать свое
    // состояние, а затем, через некоторое время восстановить работу. При этом пока она “спит” поток
    // выполнения освобождается – это называется кооперативная многозадачность. т.е. она не занимает
    // собой (своим спящем телом) наш процессор, она аккуратно освободит его другим, а затем проснется
    // и вернет его себе.

    // Ниже пример кода запуска корутины. То, что находится в фигурных скобочках после слова launch это корутина.

    // Этот кусочек кода будет запущен, отработает первый println() затем будет вызвана задержка на
    // 1 секунду при  помощи delay() – в это момент корутина “уснет” и освободит поток. Затем корутина
    // проснется и выведет следующее сообщение.

    // Запускаем приложение. В логе будет такая картина – сначала выполнился код до корутины, затем
    // после нее и затем сработало то что внутри.

    println("Code before coroutine")
    launch {
        println("Start of coroutine")
        delay(1000) // Выполнение кода будет ПРИОСТАНОВЛЕНО, поток будет освобожден для других задач.
        println("End of coroutine")
    }
    println("Code after coroutine")

    // Данный код будет запущен синхронно при этом не надо создавать никаких потоков, достаточно
    // просто написать слово launch

    // Слово launch это корутинБилдер, который определяет как именно код в фигурных скобочках будет
    // запускаться т.к. корутины могут работать по разному – на этом же потоке, на другом и т.д. То что у
    // нас между фигурными скобочками это именно тот код, который способен приостанавливаться/тормозить себя,
    // а затем пробуждаться и выполняться дальше.

}
