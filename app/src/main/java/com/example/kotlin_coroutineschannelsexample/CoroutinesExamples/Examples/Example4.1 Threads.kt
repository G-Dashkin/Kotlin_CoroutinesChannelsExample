package com.example.kotlin_coroutineschannelsexample.CoroutinesExamples.Examples

import kotlin.concurrent.thread

fun main()  {
    // Создадим код, который будет выводить длинную последовательность жучков и приведений.
    // Это будем выполняться в двух потоках.

    thread {
        for (i in 1..1000) {
            println("$i \uD83d\uDC1C")
        }
    }

    thread {
        for (i in 1..1000) {
            println("$i \uD83d\uDc7b")
        }
    }

    // Запускаем приложение и сначала жучки и мячики появляются по очереди, затем выводятся только
    // жуки и только мячики.
    // т.е. при использовании потоков мы не можем гарантировать порядок того каким образом будут
    // обрабатываться эти два разных потока, которые мы создали. При перезапуске последовательность будет уже другая.

    // Таким образом, если мы что то запускаем асинхронно таким образом, то мы не можем гарантировать порядок.
    // Например, у нас есть мобильное приложение, в котором мы что то хотим купить и у нас есть
    // возможность ввести промо код.

    // Пользователь нажимает на поле для ввода, вводит промокод и у нашего приложения появляется
    // задача – обработать ввод промокода. Далее нажимает на кнопку Submit для обработки. И пользователь
    // нажимает на Continue, чтобы система обработала то нажатие.

    // В асинхронном коде у нас отдельно будет обрабатываться промо код и нажатие на Continue, а
    // нажатие на Submit будет отдельно.

    // Если бы у нас не было асинхронности, то при нажатии на Continue промокод не применился бы,
    // так как мы сначала нажали на Continue и запрос был отправлен без применения промокода.

    // При взаимодействии с UI или сложными задачами по вычислению, разработчики должны выбрать, как
    // эти операции будут реализовываться, чтобы главный поток не блокировался

    // При работе с коллбэками может возникнуть коллбэк-хэлл
}

